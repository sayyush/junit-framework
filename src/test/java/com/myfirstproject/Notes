1. WebDriver
WebDriver is an important API in selenium
We use WebDriver to create driver object(chrome driver, safari, edge, firefox, headless,..)
2. Job title
-QA Engineer, Quality Assurance, SDET, …..
-If there is Selenium keyword in job description, you can apply
3. Framework
It is a combination of packages, classes, methods to keep our codes organized.
4. Manual vs Automation
Automation is simply done for keeping the test step stable and execution test cases faster
5. Advantages & Disadvantages
Selenium is number 1 WEB APPLICATION TESTING TOOL, open source, has large user base, works with multiple browsers, and languages
Cannot automate mobile and desktop applications with out 3rd party tools such as Appium and Auto IT, cannot handle captcha, no professional customer support
6. Functional & Non Functional Testing
Functionality is the answer of what should be done(button click, search, check out,…), non - functional is the answer of how should be done(performance, security,…)
7. Testing Types
Static: done without code such as document review
Dynamic(non-static): done with some type of coding(functional and non functional)
8. Selenium Architecture
W3C protocol
There is request and response between client side (selenium binding) and server side(drivers)
9. Selenium framework installation
We need to be organized to create a framework
We use dependencies in MAVEN project to add selenium, WebDriver, junit, testNG, cucumber,….
Collapse


* driver is api, and browser is an application


* we add selenium dependency on IntelliJ
IntelliJ is an IDE(integrated development environment).
It is development environment.
For ex: Intellij is a car. Selenium ia the engine of the car.
IDE is a software application that helps programmers develop software code efficiently.
Selenium is a library.


* Maven is not a library, it is a project build tool, especially Java.

Where do you get your dependencies in your company?
from MAVEN repository  <<= it is wrong answer
from my company <<= it is true answer

Locators - yer bulucu, konum belirleyici
teardown - destroy breaking smth, seperate each other.
quit - iptal etmek / cikis/ cik

* Anything on the webpage is called "WEBELEMENT", ex: button, search box, text box, headers, tables.


   /*
     ****** What is the difference between get() and navigate() to functions?
     * Similarities: both let you go to a page
     * get is more common than navigate to. it is easy to read
     * get accepts ONLY String as url, navigate to accepts both String and URL
     * navigate has more options such as to(), back(), forward(), refresh()
     *
     * ****** What is the difference between close() and quit()?
     * close() cleses ONLY last active window
     * quit() closes ALL ACTIVE windows
     * recommendation is use quit at the end of the last test case

      */


implicit(tam) wait. wait UP to 30 second  recommended
        // implicit wait it is dynamic wait, this is recommended to use right after CREATING THE DRIVER. It means wait, whenever I use driver
        // in tHis class WAIT up to 20 seconds, if needed. If driver does not need to wait driver is gonna continue to execution as a normal
        // fast pace. implicitlyWait will wait make the driver wait for 10 seconds. By default driver waits about 0.4 second less than a second.
        // less than 1 second by default.
        // If it does not open in 20seconds, it will fail.
        // wait and synchronization are very important for UI testing.
        // Timeouts is the interface for managing driver timeouts(zamanasimi).
        // If your testing is slow, then your test case can fail
        // implicitlyWait() Gets the amount of time,the driver should wait when searching for an element if it is not immediately present.

2 tane wait var Thread. sleep (explicit wait)
                Implicit wait if you dont need

          /*
                   There are 6 JUnit annotations
                1. @Test ==> Used to create test case
                   Test methods must have @Test annotation. They must be public and void because they are created to do assertions.
                2. @Before and @After ==> Used to run before and after EACH @Test method
                3. @BeforeClass and @AfterClass ==> Used to run before and after EACH Class only ONCE. These methods must be static
                4. @Ignore ==> Used to SKIP a test case  (ex: mesela test case 4 u ==> you are working on a project and
                   you haven't finished this yet or there is something wrong here then you will ignore that part in group run and  you can run others)
                */


                    Handling DYNAMIC elements
   DYNAMIC element is the element whose value can change.
                    How do you handle how do you locate Dynamic element?
I write dynamic xpath such as "contains", "starts with", "ends with" functions.
//tag[contains(@attribute,'value')]
//tag[starts-with(@attribute,'value')]
//tag[ends-with(@attribute,'value')]
//*[starts-with[@attribute,'value')]
//*[contains(@attribute,'value')]

For example :
Welcome to the page  (it is title)
<h2 id="pageContent" class="nav-flex" name="sub-header">Welcome to the page</h2>


//tag[text()='text value']            ==>   //h2[text='Welcome to the page']
//tag[contains(text(),'text value')]   ==> //h2[contains(text(),'Welcome to')]

//tag[XPath Statement-1 or XPath Statement-2]    ==>      //h2[@id='page-ent' or @class='nav-flex']
                                                         //h2[@id='page-ent'] OR h2[@class='nav-flex']

//tag[XPath Statement-1 and XPath Statement-2]    ==>    //h2[@id='page-ent' and @class='nav-flex']

This is the most commonly used syntax :
// tagname[@attribute='Value']


Note :
 tag can be replaced with * if you want to ignore tag (* refers to ANY tag     . refers to any attribute)